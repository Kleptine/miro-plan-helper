<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Tagger</title>
    <!-- Miro SDK -->
    <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for the panel */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #888; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555; 
        }
        
        .emoji-btn {
            transition: transform 0.1s, background-color 0.2s;
        }
        .emoji-btn:active {
            transform: scale(0.95);
        }

        .color-toggle {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.15s, box-shadow 0.15s;
        }
        .color-toggle:hover {
            transform: scale(1.05);
        }
        .color-toggle.active {
            border-color: #1a1a1a;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.15);
        }
        .color-toggle.transparent-toggle {
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
                              linear-gradient(-45deg, #ccc 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #ccc 75%),
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
        }
    </style>
</head>
<body class="bg-white text-gray-800 font-sans">

    <!-- Container handled by JS visibility -->
    <div id="app-container" class="hidden p-4">
        
        <!-- Header -->
        <div class="mb-4 text-center">
            <h1 class="text-lg font-bold text-gray-900">Box Emoji Tagger</h1>
            <p class="text-xs text-gray-500 mt-1">Select a box and click an emoji</p>
        </div>

        <!-- Status Indicator -->
        <div id="status-msg" class="text-sm text-center mb-4 text-blue-600 font-medium">
            Checking selection...
        </div>

        <!-- Emoji Grid -->
        <div class="grid grid-cols-4 gap-2 mb-6">
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚úÖ">‚úÖ</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚ùå">‚ùå</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚ö†Ô∏è">‚ö†Ô∏è</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üöß">üöß</button>
            
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üî•">üî•</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üí°">üí°</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚≠ê">‚≠ê</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üëÄ">üëÄ</button>

            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üöÄ">üöÄ</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üêõ">üêõ</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üé®">üé®</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üìù">üìù</button>
        </div>

        <!-- Color Section -->
        <div class="border-t pt-4 mb-4">
            <h2 class="text-sm font-semibold text-gray-700 mb-2">Background Colors</h2>
            <p class="text-xs text-gray-500 mb-3">Toggle colors, then Apply</p>
            <div id="color-toggles" class="flex gap-2 mb-3">
                <!-- Color toggles generated by JS -->
            </div>
            <button id="apply-colors-btn" class="w-full py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white rounded text-sm font-medium transition-colors">
                Apply Colors
            </button>
        </div>

        <!-- Actions -->
        <div class="border-t pt-4">
             <button id="clear-btn" class="w-full py-2 px-4 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded text-sm font-medium transition-colors">
                Clear All Emojis
            </button>
        </div>

    </div>

    <script>
        // --- Configuration ---
        // Regex to match a wide range of Emojis (Emoji Presentation & Extended Pictographic)
        const EMOJI_REGEX = /(\p{Emoji_Presentation}|\p{Extended_Pictographic})/gu;

        // Supported widget types for emoji tagging
        const SUPPORTED_TYPES = ['shape', 'sticky_note', 'text'];

        // Stripe width in pixels (global config - adjust to taste)
        const STRIPE_WIDTH = 50;

        // Background colors (configurable) - order matters for stripes
        const BG_COLORS = [
            '#8FD14F', // Light green (0.561, 0.820, 0.310)
            '#DEDAFF', // Pale lavender (0.870, 0.855, 1.000)
            '#F8D3AF', // Peach (0.973, 0.828, 0.686)
            '#C6DCFF', // Pale blue (0.776, 0.863, 1.000)
            '#FFF6B9', // Pale yellow (1.000, 0.965, 0.726)
            'transparent', // Clear (no color)
            '#FFE600', // Golden yellow (Neon)
            '#FF7F7F', // Coral/Salmon
            '#7FDFDF', // Mint/Teal
        ];

        // Marker for our generated stripe backgrounds
        const STRIPE_BG_TITLE = '__stripe_bg__';

        async function init() {
            // Check if we are running in the sidebar (Panel) or as the background "Headless" app
            const params = new URLSearchParams(window.location.search);
            const isPanel = params.has('panel');

            if (isPanel) {
                // --- PANEL MODE (UI) ---
                document.getElementById('app-container').classList.remove('hidden');
                setupPanelLogic();
            } else {
                // --- HEADLESS MODE (Background) ---
                // This registers the app icon in the toolbar
                await miro.board.ui.on('icon:click', async () => {
                    await miro.board.ui.openPanel({
                        url: '?panel=1', // Load self with panel param
                        height: 580 // Extended height for color section
                    });
                });

                // Listen for item updates to sync stripe background size with shape
                // Note: experimental event - fires for moves, resizing, rotation, scale
                miro.board.ui.on('experimental:items:update', handleItemsUpdate);
            }
        }

        // Handle item updates - sync stripe background size when shape is resized
        async function handleItemsUpdate(event) {
            for (const item of event.items) {
                // Only care about shapes
                if (item.type !== 'shape') continue;

                // Check if this shape is in one of our stripe groups
                if (!item.parentId) continue;

                try {
                    const parent = await miro.board.getById(item.parentId);
                    if (!parent || parent.type !== 'group') continue;

                    const isOurs = await isStripeGroup(parent);
                    if (!isOurs) continue;

                    // Find the stripe image in the group and resize it to match the shape
                    const groupItems = await parent.getItems();
                    for (const groupItem of groupItems) {
                        if (groupItem.type === 'image' && groupItem.url && groupItem.url.startsWith('data:image/svg+xml;base64,')) {
                            // Update image dimensions to match shape (stretching is fine)
                            groupItem.width = item.width;
                            groupItem.height = item.height;
                            groupItem.x = item.x;
                            groupItem.y = item.y;
                            groupItem.rotation = item.rotation || 0;
                            await groupItem.sync();
                            break;
                        }
                    }
                } catch (err) {
                    // Silently ignore errors - shape might have been deleted or ungrouped
                }
            }
        }

        // Track active color toggles (indices into BG_COLORS)
        let activeColors = new Set();

        function setupPanelLogic() {
            const statusMsg = document.getElementById('status-msg');
            const clearBtn = document.getElementById('clear-btn');
            const emojiBtns = document.querySelectorAll('.emoji-btn');
            const colorTogglesContainer = document.getElementById('color-toggles');
            const applyColorsBtn = document.getElementById('apply-colors-btn');

            // Generate color toggle buttons
            BG_COLORS.forEach((color, index) => {
                const btn = document.createElement('button');
                btn.className = 'color-toggle';
                if (color === 'transparent') {
                    btn.classList.add('transparent-toggle');
                } else {
                    btn.style.backgroundColor = color;
                }
                btn.dataset.colorIndex = index;
                btn.addEventListener('click', () => {
                    if (activeColors.has(index)) {
                        activeColors.delete(index);
                        btn.classList.remove('active');
                    } else {
                        activeColors.add(index);
                        btn.classList.add('active');
                    }
                });
                colorTogglesContainer.appendChild(btn);
            });

            // Handle Apply Colors
            applyColorsBtn.addEventListener('click', async () => {
                await applyBackgroundColors();
            });

            // 1. Listen for selection updates to update UI status
            miro.board.ui.on('selection:update', async (event) => {
                updateStatus(event.items);
                // Reset color toggles on new selection
                activeColors.clear();
                document.querySelectorAll('.color-toggle').forEach(btn => btn.classList.remove('active'));
            });

            // Initial check
            miro.board.getSelection().then(updateStatus);

            // 2. Handle Emoji Click
            emojiBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const emoji = btn.dataset.emoji;
                    await applyEmoji(emoji);
                });
            });

            // 3. Handle Clear Click
            clearBtn.addEventListener('click', async () => {
                await applyEmoji(null); // null means clear only
            });

            async function updateStatus(items) {
                const supportedItems = items.filter(i => SUPPORTED_TYPES.includes(i.type));
                
                if (items.length === 0) {
                    statusMsg.textContent = "Select a box to start";
                    statusMsg.className = "text-sm text-center mb-4 text-gray-400";
                    toggleButtons(false);
                } else if (supportedItems.length === 0) {
                    statusMsg.textContent = "Selection not supported (Shapes/Stickies only)";
                    statusMsg.className = "text-sm text-center mb-4 text-red-500";
                    toggleButtons(false);
                } else {
                    statusMsg.textContent = `${supportedItems.length} item(s) selected`;
                    statusMsg.className = "text-sm text-center mb-4 text-green-600 font-medium";
                    toggleButtons(true);
                }
            }

            function toggleButtons(enable) {
                const opacity = enable ? '1' : '0.5';
                const pointerEvents = enable ? 'auto' : 'none';
                
                document.querySelector('.grid').style.opacity = opacity;
                document.querySelector('.grid').style.pointerEvents = pointerEvents;
                clearBtn.style.opacity = opacity;
                clearBtn.style.pointerEvents = pointerEvents;
            }
        }

        async function applyEmoji(newEmoji) {
            // Get current selection
            const items = await miro.board.getSelection();
            
            // Filter for supported types
            const supportedItems = items.filter(i => SUPPORTED_TYPES.includes(i.type));

            if (supportedItems.length === 0) return;

            // Process each item
            for (const item of supportedItems) {
                // Get current content (usually HTML or plain text)
                let currentContent = item.content || "";

                // Remove existing emojis using regex
                // We use a replacer function to avoid stripping HTML tags that might look like emojis (unlikely but safe)
                // However, simple regex replace on the string is standard for this use case in Miro
                let cleanContent = currentContent.replace(EMOJI_REGEX, '');

                // Remove any trailing spaces that might have been left behind after emoji removal
                // This handles both plain text and HTML-wrapped content
                cleanContent = cleanContent.replace(/\s+(<\/p>)$/g, '$1'); // Remove spaces before closing </p> tag
                cleanContent = cleanContent.replace(/\s+$/g, ''); // Remove trailing spaces in plain text

                // Append new emoji if provided
                let finalContent = cleanContent;
                if (newEmoji) {
                    // Check if content is wrapped in HTML tags (Miro often wraps text in <p>)
                    if (finalContent.endsWith('</p>')) {
                        // Insert before the closing tag
                        finalContent = finalContent.replace(/<\/p>$/, ` ${newEmoji}</p>`);
                    } else {
                        // Plain append
                        finalContent = `${finalContent} ${newEmoji}`;
                    }
                }

                // Update the item
                item.content = finalContent;
                
                // Sync changes to board
                try {
                    await item.sync();
                } catch (err) {
                    console.error("Failed to sync item", err);
                }
            }
        }

        // --- Background Color Functions ---

        async function applyBackgroundColors() {
            const items = await miro.board.getSelection();

            // Filter for rectangle shapes only
            const rectangles = items.filter(i => i.type === 'shape' && i.shape === 'rectangle');

            if (rectangles.length === 0) {
                console.log('No rectangles selected');
                return;
            }

            // Get selected colors in fixed order
            const selectedColors = Array.from(activeColors)
                .sort((a, b) => a - b)
                .map(i => BG_COLORS[i]);

            for (let shape of rectangles) {
                try {
                    // Check if shape is already in a group
                    if (shape.parentId) {
                        // Check if it's our stripe group
                        const parent = await miro.board.getById(shape.parentId);
                        if (parent && parent.type === 'group') {
                            const isOurGroup = await isStripeGroup(parent);
                            if (!isOurGroup) {
                                console.warn('Shape is in a user-created group, skipping:', shape.id);
                                continue;
                            }
                            // It's our group - clean it up first
                            await cleanupStripeGroup(parent);
                            // Re-fetch shape after ungrouping (local object is stale)
                            shape = await miro.board.getById(shape.id);
                        }
                    }

                    // Filter out transparent for counting visible colors
                    const visibleColors = selectedColors.filter(c => c !== 'transparent');

                    // Apply based on number of visible colors
                    if (visibleColors.length === 0) {
                        // No visible colors (none selected, or only transparent)
                        shape.style.fillOpacity = 0;
                        await shape.sync();
                    } else if (visibleColors.length === 1) {
                        // Single visible color - direct fillColor
                        shape.style.fillColor = visibleColors[0];
                        shape.style.fillOpacity = 1;
                        await shape.sync();
                    } else {
                        // Multiple colors - create striped background
                        await createStripedBackground(shape, selectedColors);
                    }
                } catch (err) {
                    console.error('Failed to apply colors to shape:', shape.id, err);
                }
            }
        }

        async function isStripeGroup(group) {
            try {
                const items = await group.getItems();
                if (items.length !== 2) return false;

                // Identify our stripe images by their data URL pattern (more reliable than title)
                const hasStripeImage = items.some(i =>
                    i.type === 'image' && i.url && i.url.startsWith('data:image/svg+xml;base64,')
                );
                const hasShape = items.some(i => i.type === 'shape');
                return hasStripeImage && hasShape;
            } catch (err) {
                return false;
            }
        }

        async function cleanupStripeGroup(group) {
            try {
                const items = await group.getItems();
                await group.ungroup();

                // Delete the stripe background image (identified by data URL pattern)
                for (const item of items) {
                    if (item.type === 'image' && item.url && item.url.startsWith('data:image/svg+xml;base64,')) {
                        await miro.board.remove(item);
                    }
                }
            } catch (err) {
                console.error('Failed to cleanup stripe group:', err);
            }
        }

        function generateStripeSvg(width, height, colors) {
            // Filter out transparent colors for stripe generation
            const visibleColors = colors.filter(c => c !== 'transparent');
            if (visibleColors.length === 0) return null;

            // Use global stripe width config
            const stripeWidth = STRIPE_WIDTH;
            // Need enough stripes to cover from -height to width (diagonal coverage)
            const totalLen = width + height;
            const numStripes = Math.ceil(totalLen / stripeWidth) + visibleColors.length;

            // Build diagonal stripes using parallelograms
            // Each stripe runs from top-left to bottom-right at 45 degrees
            let stripes = '';
            for (let i = 0; i < numStripes; i++) {
                const color = visibleColors[i % visibleColors.length];
                const x1 = i * stripeWidth - height;
                const x2 = (i + 1) * stripeWidth - height;
                // Parallelogram: top edge at y=0, bottom edge at y=height, shifted by height
                stripes += `<polygon points="${x1},0 ${x2},0 ${x2 + height},${height} ${x1 + height},${height}" fill="${color}"/>`;
            }

            return `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <clipPath id="c"><rect width="${width}" height="${height}"/></clipPath>
                </defs>
                <g clip-path="url(#c)">${stripes}</g>
            </svg>`;
        }

        // Convert frame-relative coordinates to absolute board coordinates
        // Frame children have x/y relative to frame's top-left corner
        // Board items have x/y relative to board center
        async function getAbsoluteBoardCoords(item) {
            if (!item.parentId) {
                // Item is at board root - coordinates are already absolute
                return { x: item.x, y: item.y };
            }

            // Item is inside a frame - convert from frame-relative to board coords
            const parent = await miro.board.getById(item.parentId);
            if (!parent) {
                console.warn('Parent not found, using relative coords');
                return { x: item.x, y: item.y };
            }

            // Frame's x/y is its CENTER in board coords
            // Child's x/y is relative to frame's TOP-LEFT corner
            // So: boardX = (frame.x - frame.width/2) + child.x
            const boardX = (parent.x - parent.width / 2) + item.x;
            const boardY = (parent.y - parent.height / 2) + item.y;

            return { x: boardX, y: boardY };
        }

        async function createStripedBackground(shape, colors) {
            const width = shape.width;
            const height = shape.height;

            // Generate SVG
            const svg = generateStripeSvg(width, height, colors);
            if (!svg) {
                // Only transparent colors selected - just make shape transparent
                shape.style.fillOpacity = 0;
                await shape.sync();
                return;
            }
            const base64 = btoa(svg);
            const dataUrl = `data:image/svg+xml;base64,${base64}`;

            // Get absolute board coordinates for the shape
            const absCoords = await getAbsoluteBoardCoords(shape);

            // Create image at absolute board coordinates
            const bgImage = await miro.board.createImage({
                url: dataUrl,
                title: STRIPE_BG_TITLE,
                x: absCoords.x,
                y: absCoords.y,
                width: width,
                rotation: shape.rotation || 0,
            });

            // Make shape transparent so stripes show through
            shape.style.fillOpacity = 0;
            await shape.sync();

            // Send image behind the shape (not to absolute back)
            await miro.board.sendBehindOf(bgImage, shape);

            // Group them together
            await miro.board.group({
                items: [bgImage, shape]
            });
        }

        // Initialize the app
        init();
    </script>
</body>
</html>