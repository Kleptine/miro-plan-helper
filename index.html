<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Tagger</title>
    <!-- Miro SDK -->
    <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for the panel */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #888; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555; 
        }
        
        .emoji-btn {
            transition: transform 0.1s, background-color 0.2s;
        }
        .emoji-btn:active {
            transform: scale(0.95);
        }

        .color-toggle {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.15s, box-shadow 0.15s;
        }
        .color-toggle:hover {
            transform: scale(1.05);
        }
        .color-toggle.active {
            border-color: #1a1a1a;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body class="bg-white text-gray-800 font-sans">

    <!-- Container handled by JS visibility -->
    <div id="app-container" class="hidden p-4">
        
        <!-- Header -->
        <div class="mb-4 text-center">
            <h1 class="text-lg font-bold text-gray-900">Box Emoji Tagger</h1>
            <p class="text-xs text-gray-500 mt-1">Select a box and click an emoji</p>
        </div>

        <!-- Status Indicator -->
        <div id="status-msg" class="text-sm text-center mb-4 text-blue-600 font-medium">
            Checking selection...
        </div>

        <!-- Emoji Grid -->
        <div class="grid grid-cols-4 gap-2 mb-6">
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚úÖ">‚úÖ</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚ùå">‚ùå</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚ö†Ô∏è">‚ö†Ô∏è</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üöß">üöß</button>
            
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üî•">üî•</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üí°">üí°</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="‚≠ê">‚≠ê</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üëÄ">üëÄ</button>

            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üöÄ">üöÄ</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üêõ">üêõ</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üé®">üé®</button>
            <button class="emoji-btn text-2xl p-2 rounded hover:bg-gray-100 border border-transparent hover:border-gray-200" data-emoji="üìù">üìù</button>
        </div>

        <!-- Color Section -->
        <div class="border-t pt-4 mb-4">
            <h2 class="text-sm font-semibold text-gray-700 mb-2">Background Colors</h2>
            <p class="text-xs text-gray-500 mb-3">Toggle colors, then Apply</p>
            <div id="color-toggles" class="flex gap-2 mb-3">
                <!-- Color toggles generated by JS -->
            </div>
            <button id="apply-colors-btn" class="w-full py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white rounded text-sm font-medium transition-colors">
                Apply Colors
            </button>
        </div>

        <!-- Actions -->
        <div class="border-t pt-4">
             <button id="clear-btn" class="w-full py-2 px-4 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded text-sm font-medium transition-colors">
                Clear All Emojis
            </button>
        </div>

    </div>

    <script>
        // --- Configuration ---
        // Regex to match a wide range of Emojis (Emoji Presentation & Extended Pictographic)
        const EMOJI_REGEX = /(\p{Emoji_Presentation}|\p{Extended_Pictographic})/gu;

        // Supported widget types for emoji tagging
        const SUPPORTED_TYPES = ['shape', 'sticky_note', 'text'];

        // Background colors (configurable) - order matters for stripes
        const BG_COLORS = [
            '#FF6B6B', // Red
            '#4ECDC4', // Teal
            '#45B7D1', // Blue
            '#96CEB4', // Green
            '#FFEAA7', // Yellow
            '#DDA0DD', // Plum
        ];

        // Marker for our generated stripe backgrounds
        const STRIPE_BG_TITLE = '__stripe_bg__';

        async function init() {
            // Check if we are running in the sidebar (Panel) or as the background "Headless" app
            const params = new URLSearchParams(window.location.search);
            const isPanel = params.has('panel');

            if (isPanel) {
                // --- PANEL MODE (UI) ---
                document.getElementById('app-container').classList.remove('hidden');
                setupPanelLogic();
            } else {
                // --- HEADLESS MODE (Background) ---
                // This registers the app icon in the toolbar
                await miro.board.ui.on('icon:click', async () => {
                    await miro.board.ui.openPanel({
                        url: '?panel=1', // Load self with panel param
                        height: 580 // Extended height for color section
                    });
                });
            }
        }

        // Track active color toggles (indices into BG_COLORS)
        let activeColors = new Set();

        function setupPanelLogic() {
            const statusMsg = document.getElementById('status-msg');
            const clearBtn = document.getElementById('clear-btn');
            const emojiBtns = document.querySelectorAll('.emoji-btn');
            const colorTogglesContainer = document.getElementById('color-toggles');
            const applyColorsBtn = document.getElementById('apply-colors-btn');

            // Generate color toggle buttons
            BG_COLORS.forEach((color, index) => {
                const btn = document.createElement('button');
                btn.className = 'color-toggle';
                btn.style.backgroundColor = color;
                btn.dataset.colorIndex = index;
                btn.addEventListener('click', () => {
                    if (activeColors.has(index)) {
                        activeColors.delete(index);
                        btn.classList.remove('active');
                    } else {
                        activeColors.add(index);
                        btn.classList.add('active');
                    }
                });
                colorTogglesContainer.appendChild(btn);
            });

            // Handle Apply Colors
            applyColorsBtn.addEventListener('click', async () => {
                await applyBackgroundColors();
            });

            // 1. Listen for selection updates to update UI status
            miro.board.ui.on('selection:update', async (event) => {
                updateStatus(event.items);
                // Reset color toggles on new selection
                activeColors.clear();
                document.querySelectorAll('.color-toggle').forEach(btn => btn.classList.remove('active'));
            });

            // Initial check
            miro.board.getSelection().then(updateStatus);

            // 2. Handle Emoji Click
            emojiBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const emoji = btn.dataset.emoji;
                    await applyEmoji(emoji);
                });
            });

            // 3. Handle Clear Click
            clearBtn.addEventListener('click', async () => {
                await applyEmoji(null); // null means clear only
            });

            async function updateStatus(items) {
                const supportedItems = items.filter(i => SUPPORTED_TYPES.includes(i.type));
                
                if (items.length === 0) {
                    statusMsg.textContent = "Select a box to start";
                    statusMsg.className = "text-sm text-center mb-4 text-gray-400";
                    toggleButtons(false);
                } else if (supportedItems.length === 0) {
                    statusMsg.textContent = "Selection not supported (Shapes/Stickies only)";
                    statusMsg.className = "text-sm text-center mb-4 text-red-500";
                    toggleButtons(false);
                } else {
                    statusMsg.textContent = `${supportedItems.length} item(s) selected`;
                    statusMsg.className = "text-sm text-center mb-4 text-green-600 font-medium";
                    toggleButtons(true);
                }
            }

            function toggleButtons(enable) {
                const opacity = enable ? '1' : '0.5';
                const pointerEvents = enable ? 'auto' : 'none';
                
                document.querySelector('.grid').style.opacity = opacity;
                document.querySelector('.grid').style.pointerEvents = pointerEvents;
                clearBtn.style.opacity = opacity;
                clearBtn.style.pointerEvents = pointerEvents;
            }
        }

        async function applyEmoji(newEmoji) {
            // Get current selection
            const items = await miro.board.getSelection();
            
            // Filter for supported types
            const supportedItems = items.filter(i => SUPPORTED_TYPES.includes(i.type));

            if (supportedItems.length === 0) return;

            // Process each item
            for (const item of supportedItems) {
                // Get current content (usually HTML or plain text)
                let currentContent = item.content || "";

                // Remove existing emojis using regex
                // We use a replacer function to avoid stripping HTML tags that might look like emojis (unlikely but safe)
                // However, simple regex replace on the string is standard for this use case in Miro
                let cleanContent = currentContent.replace(EMOJI_REGEX, '');

                // Remove any trailing spaces that might have been left behind after emoji removal
                // This handles both plain text and HTML-wrapped content
                cleanContent = cleanContent.replace(/\s+(<\/p>)$/g, '$1'); // Remove spaces before closing </p> tag
                cleanContent = cleanContent.replace(/\s+$/g, ''); // Remove trailing spaces in plain text

                // Append new emoji if provided
                let finalContent = cleanContent;
                if (newEmoji) {
                    // Check if content is wrapped in HTML tags (Miro often wraps text in <p>)
                    if (finalContent.endsWith('</p>')) {
                        // Insert before the closing tag
                        finalContent = finalContent.replace(/<\/p>$/, ` ${newEmoji}</p>`);
                    } else {
                        // Plain append
                        finalContent = `${finalContent} ${newEmoji}`;
                    }
                }

                // Update the item
                item.content = finalContent;
                
                // Sync changes to board
                try {
                    await item.sync();
                } catch (err) {
                    console.error("Failed to sync item", err);
                }
            }
        }

        // --- Background Color Functions ---

        async function applyBackgroundColors() {
            const items = await miro.board.getSelection();

            // Filter for rectangle shapes only
            const rectangles = items.filter(i => i.type === 'shape' && i.shape === 'rectangle');

            if (rectangles.length === 0) {
                console.log('No rectangles selected');
                return;
            }

            // Get selected colors in fixed order
            const selectedColors = Array.from(activeColors)
                .sort((a, b) => a - b)
                .map(i => BG_COLORS[i]);

            for (let shape of rectangles) {
                try {
                    // Check if shape is already in a group
                    if (shape.parentId) {
                        // Check if it's our stripe group
                        const parent = await miro.board.getById(shape.parentId);
                        if (parent && parent.type === 'group') {
                            const isOurGroup = await isStripeGroup(parent);
                            if (!isOurGroup) {
                                console.warn('Shape is in a user-created group, skipping:', shape.id);
                                continue;
                            }
                            // It's our group - clean it up first
                            await cleanupStripeGroup(parent);
                            // Re-fetch shape after ungrouping (local object is stale)
                            shape = await miro.board.getById(shape.id);
                        }
                    }

                    // Apply based on number of colors
                    if (selectedColors.length === 0) {
                        // Transparent - just set fillOpacity to 0
                        shape.style.fillOpacity = 0;
                        await shape.sync();
                    } else if (selectedColors.length === 1) {
                        // Single color - direct fillColor
                        shape.style.fillColor = selectedColors[0];
                        shape.style.fillOpacity = 1;
                        await shape.sync();
                    } else {
                        // Multiple colors - create striped background
                        await createStripedBackground(shape, selectedColors);
                    }
                } catch (err) {
                    console.error('Failed to apply colors to shape:', shape.id, err);
                }
            }
        }

        async function isStripeGroup(group) {
            try {
                const items = await group.getItems();
                if (items.length !== 2) return false;

                const hasImage = items.some(i => i.type === 'image' && i.title === STRIPE_BG_TITLE);
                const hasShape = items.some(i => i.type === 'shape');
                return hasImage && hasShape;
            } catch (err) {
                return false;
            }
        }

        async function cleanupStripeGroup(group) {
            try {
                const items = await group.getItems();
                await group.ungroup();

                // Delete the stripe background image
                for (const item of items) {
                    if (item.type === 'image' && item.title === STRIPE_BG_TITLE) {
                        await miro.board.remove(item);
                    }
                }
            } catch (err) {
                console.error('Failed to cleanup stripe group:', err);
            }
        }

        function generateStripeSvg(width, height, colors) {
            const stripeWidth = Math.max(15, Math.min(width, height) / 8);
            const diagonal = Math.sqrt(width * width + height * height);
            // Extra coverage for rotated corners
            const coverage = diagonal * 1.5;
            const numStripes = Math.ceil(coverage * 2 / stripeWidth) + colors.length;

            let stripes = '';
            for (let i = 0; i < numStripes; i++) {
                const color = colors[i % colors.length];
                const x = (i * stripeWidth) - coverage;
                stripes += `<rect x="${x}" y="${-coverage}" width="${stripeWidth}" height="${coverage * 3}" fill="${color}" />`;
            }

            return `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <clipPath id="clip">
                        <rect x="0" y="0" width="${width}" height="${height}" />
                    </clipPath>
                </defs>
                <g clip-path="url(#clip)" transform="rotate(-45, ${width/2}, ${height/2})">
                    ${stripes}
                </g>
            </svg>`;
        }

        // Convert frame-relative coordinates to absolute board coordinates
        // Frame children have x/y relative to frame's top-left corner
        // Board items have x/y relative to board center
        async function getAbsoluteBoardCoords(item) {
            if (!item.parentId) {
                // Item is at board root - coordinates are already absolute
                return { x: item.x, y: item.y };
            }

            // Item is inside a frame - convert from frame-relative to board coords
            const parent = await miro.board.getById(item.parentId);
            if (!parent) {
                console.warn('Parent not found, using relative coords');
                return { x: item.x, y: item.y };
            }

            // Frame's x/y is its CENTER in board coords
            // Child's x/y is relative to frame's TOP-LEFT corner
            // So: boardX = (frame.x - frame.width/2) + child.x
            const boardX = (parent.x - parent.width / 2) + item.x;
            const boardY = (parent.y - parent.height / 2) + item.y;

            return { x: boardX, y: boardY };
        }

        async function createStripedBackground(shape, colors) {
            const width = shape.width;
            const height = shape.height;

            // Generate SVG
            const svg = generateStripeSvg(width, height, colors);
            const base64 = btoa(svg);
            const dataUrl = `data:image/svg+xml;base64,${base64}`;

            // Get absolute board coordinates for the shape
            const absCoords = await getAbsoluteBoardCoords(shape);

            // Create image at absolute board coordinates
            const bgImage = await miro.board.createImage({
                url: dataUrl,
                title: STRIPE_BG_TITLE,
                x: absCoords.x,
                y: absCoords.y,
                width: width,
                rotation: shape.rotation || 0,
            });

            // Make shape transparent so stripes show through
            shape.style.fillOpacity = 0;
            await shape.sync();

            // Send image behind the shape (not to absolute back)
            await miro.board.sendBehindOf(bgImage, shape);

            // Group them together
            await miro.board.group({
                items: [bgImage, shape]
            });
        }

        // Initialize the app
        init();
    </script>
</body>
</html>